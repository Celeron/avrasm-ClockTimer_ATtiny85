.IFNDEF	_PROCDISPLAYOUTPUT__INCLUDED_
.EQU	_PROCDISPLAYOUTPUT__INCLUDED_ = 1
.MESSAGE "Note: <procDisplayOutput.inc> have included!" 
;=== BEGIN "procDisplayOutput.inc" =========================================
; Блок отлаженных и функционально обособленных процедур, предназначенных для поддержки ВЫВОДА: на семисегментные индикаторы, статическим способом, через сдвиговые регистры.
; Выделено в отдельный файл, для удобства...



; Чтобы включить отладочный Вывод на дисплей-индикатор - раскомментируйте это определение:
; (см. также настройку отладочного вывода - в процедуре DISPLAY_PRINT_DEBUGSTUB)
;.EQU	TURN_DEBUG_OUTPUT_ON = 1


;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; Процедура Вывода на дисплей-индикатор:
;
; 	DISPLAY_PREPARE	(подготовить инфо)
; 	построение выводимой строки байт DOutputDisplayString, 
; 	в зависимости от текущего режима интерфейса и функций
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables
;
; Без параметров.
;
; Памятка: также использует/портит содержимое регистров: 
;	TEMP1 (опосредованно для SETB/CLRB/STOREB/LOADB/OUTI и др), 
;	TEMP2, TEMP3, TEMP4,		(опосредованно в DISPLAY_PRINT_DIGITS),
;	X(R27:R26), Y(R29:R28)		(опосредованно в DISPLAY_PRINT_DIGITS),
;	R25, Z(R31:R30)			(опосредованноо в CODE2SYMBOL).
;
;----- Code

DISPLAY_PREPARE:
		; Очистить дисплей
		RCALL	DISPLAY_PRINT_CLEAR

		STOREB	DSleep,	DISPLAY_OFF				; Флаг "загасить дисплей" -> T
		BRTS	End__DISPLAY_PREPARE				; (слепой-режим?)

		; Определить текущий режим интерфейса (SWITCH-CASE) и обработать соответствующим кодом:
		STOREB	DMain_Mode,	MODE_SETTINGS			; Флаг "находимся в режиме настройки" -> T	(Внимание! это важный модификатор поведения функции: в "режиме настройки" - на экране отображаются не часы, а значение текущего настраиваемого параметра.)
		LDS	temp1,	DMain_Mode
		ANDI	temp1,	(0b111<<MODE_CURRENT_FUNCTION)		; Номер текущей функции (индекс перехода) -> temp1
		BRTC	NotSettingsMode__DISPLAY_PREPARE
		SUBI	temp1,	(-0b1000)				; Если "находимся в режиме настройки", то переключаемся на вторую половину таблицы переходов.
	NotSettingsMode__DISPLAY_PREPARE:
		; Примечание: Ветвление реализовано на "индексных переходах" - см. объяснение в "AVR. Учебный курс. Ветвления на индексных переходах" (с) http://easyelectronics.ru/avr-uchebnyj-kurs-vetvleniya.html
		LSL	temp1						; (Примечание: Адреса меток из CSEG выражены в Словах, поэтому их нужно увеличить в 2 раза, чтобы можно было использовать в инструкциях LPM/SPM...)
		LDI	ZL,	Low (2*SwitchTable__DISPLAY_PREPARE)
		LDI	ZH,	High(2*SwitchTable__DISPLAY_PREPARE)
		CLR	temp2
		ADD	ZL,	temp1					; Z += temp1
		ADC	ZH,	temp2
		LPM	temp1,	Z+					; загрузить адрес перехода из индексной таблицы -> [temp2:temp1]
		LPM	temp2,	Z
		MOVW	ZH:ZL,	temp2:temp1				; забросить адрес перехода на прикладную функцию -> в Z 	(Примечание: поскольку для переходов IJMP/ICALL используется Адрес выраженный в Словах - то его предварительно НЕ увеличиваем в 2 раза, оставляем таким как был загружен из таблицы...)
		IJMP							; переход на заданную "индексной таблицей" метку 

End__DISPLAY_PREPARE:
		RCALL	DISPLAY_PRINT_BUZZER				; Проверить все функции: не звонит ли где звонок?
									; Вывести (мигающие) точки для тех функций, будильники которых звонят.
									; Включить "бузер", если звонит хоть один из будильников.
	.ifdef TURN_DEBUG_OUTPUT_ON
		RCALL	DISPLAY_PRINT_DEBUGSTUB				; DEBUG: подмена регулярного вывода отладочным
	.endif
		RET



;---------------------------------------------------------------------------
; "Индексная таблица" переходов (код функии -> метка кода, который обрабатывает данную функцию):
SwitchTable__DISPLAY_PREPARE:
		.DW	RenderRTC__DISPLAY_PREPARE	; = 0b000 ; FunctionRTC		; часы реального времени
		.DW	RenderAlarm__DISPLAY_PREPARE	; = 0b001 ; FunctionALARM	; будильник
		.DW	RenderTimer1__DISPLAY_PREPARE	; = 0b010 ; FunctionTIMER1	; таймер1
		.DW	RenderTimer2__DISPLAY_PREPARE	; = 0b011 ; FunctionTIMER2	; таймер2
		.DW	End__DISPLAY_PREPARE		; = 0b100 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b101 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b110 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b111 ; (функция не реализована)
		; Если "находимся в режиме настройки", то переключаемся на вторую половину таблицы переходов	(примечание: в "режиме настройки", на экране отображаются не часы, а значение текущего настраиваемого параметра)
		.DW	SettingRTC__DISPLAY_PREPARE	; = 0b1000 ; FunctionRTC	; часы реального времени
		.DW	SettingAlarm__DISPLAY_PREPARE	; = 0b1001 ; FunctionALARM	; будильник
		.DW	SettingTimer1__DISPLAY_PREPARE	; = 0b1010 ; FunctionTIMER1	; таймер1
		.DW	SettingTimer2__DISPLAY_PREPARE	; = 0b1011 ; FunctionTIMER2	; таймер2
		.DW	End__DISPLAY_PREPARE		; = 0b1100 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b1101 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b1110 ; (функция не реализована)
		.DW	End__DISPLAY_PREPARE		; = 0b1111 ; (функция не реализована)



;---------------------------------------------------------------------------
RenderRTC__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DClock_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DClock_Mode)
		RCALL	DISPLAY_PRINT_DIGITS

		STOREB	DAlarm_Mode,	MODE_BELLRINGING			; Флаг "гудок звонит":		=0 молчит,	=1 пищит прямо сейчас (время пришло)!
		BRTC	NotRingingRTC__DISPLAY_PREPARE
		RCALL	DISPLAY_PRINT_BELLSIGN					; вывести "звоночек"
		RJMP	AfterRingingRTC__DISPLAY_PREPARE
	NotRingingRTC__DISPLAY_PREPARE:
		RCALL	DISPLAY_PRINT_SECONDSIGN				; вывести "чёрточку"
	AfterRingingRTC__DISPLAY_PREPARE:

		SETB	(DOutputDisplayString+PositionLH),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в левом индикаторе
		RJMP	End__DISPLAY_PREPARE


RenderAlarm__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DAlarm_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DAlarm_Mode)
		RCALL	DISPLAY_PRINT_DIGITS

		STOREB	DAlarm_Mode,	MODE_ENABLED				; Флаг "режим активности":	=0 деактивирован,	=1 активен (будет звонить)
		BRTC	NotRingingAlarm__DISPLAY_PREPARE
		RCALL	DISPLAY_PRINT_BELLSIGN					; Если бит MODE_ENABLED == 1 (звонок активен), то отображаем колбасящийся звонок. 
	NotRingingAlarm__DISPLAY_PREPARE:					; Иначе, "звонок деактивирован" - на среднем индикаторе будет пусто.

		SETB	(DOutputDisplayString+PositionRH),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в четвёртом слева индикаторе
		RJMP	End__DISPLAY_PREPARE


RenderTimer1__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DTimer1_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DTimer1_Mode)
		RCALL	DISPLAY_PRINT_DIGITS
		
		LDS	TimerMode,	DTimer1_Mode
		RCALL	DISPLAY_PRINT_TIMER_MODE				; Отрендерить для функции "Таймер" средний индикатор (индикатор режима) на дисплее.

		SETB	(DOutputDisplayString+PositionLL),	SegmentBit_H	; признак "текущего режима": зажигаем точечку во втором слева индикаторе
		RJMP	End__DISPLAY_PREPARE


RenderTimer2__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DTimer2_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DTimer2_Mode)
		RCALL	DISPLAY_PRINT_DIGITS

		LDS	TimerMode,	DTimer2_Mode
		RCALL	DISPLAY_PRINT_TIMER_MODE				; Отрендерить для функции "Таймер" средний индикатор (индикатор режима) на дисплее.

		SETB	(DOutputDisplayString+PositionM),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в третьем слева индикаторе
		RJMP	End__DISPLAY_PREPARE



;---------------------------------------------------------------------------
SettingRTC__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DClock_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DClock_Mode)
		RCALL	DISPLAY_PRINT_SETTINGS

		SETB	(DOutputDisplayString+PositionLH),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в левом индикаторе
		RJMP	End__DISPLAY_PREPARE


SettingAlarm__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DAlarm_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DAlarm_Mode)
		RCALL	DISPLAY_PRINT_SETTINGS

		SETB	(DOutputDisplayString+PositionRH),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в четвёртом слева индикаторе
		RJMP	End__DISPLAY_PREPARE


SettingTimer1__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DTimer1_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DTimer1_Mode)
		RCALL	DISPLAY_PRINT_SETTINGS
		
		SETB	(DOutputDisplayString+PositionLL),	SegmentBit_H	; признак "текущего режима": зажигаем точечку во втором слева индикаторе
		RJMP	End__DISPLAY_PREPARE


SettingTimer2__DISPLAY_PREPARE:
		LDI	FunctionModeAddressLow,		Low(DTimer2_Mode)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	FunctionModeAddressHigh,	High(DTimer2_Mode)
		RCALL	DISPLAY_PRINT_SETTINGS

		SETB	(DOutputDisplayString+PositionM),	SegmentBit_H	; признак "текущего режима": зажигаем точечку в третьем слева индикаторе
		RJMP	End__DISPLAY_PREPARE



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
;
; 	DISPLAY_PRINT_CLEAR	(подготовить инфо)
; Очистить дисплей. Обнулить всю выводимую строку DOutputDisplayString. (для инициализации)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Памятка: также использует/портит содержимое регистров: TEMP.

;----- Code

DISPLAY_PRINT_CLEAR:
		;CLR	temp
		LDS	temp,	(DSymbolsTable+SymbolBlank)
		STS	(DOutputDisplayString+PositionRL),	temp
		STS	(DOutputDisplayString+PositionRH),	temp
		STS	(DOutputDisplayString+PositionM),	temp
		STS	(DOutputDisplayString+PositionLL),	temp
		STS	(DOutputDisplayString+PositionLH),	temp
		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
;
; 	DISPLAY_PRINT_TIMER_MODE	(подготовить инфо)
; Отрендерить для функции "Таймер" средний индикатор (индикатор режима) на дисплее.
; (повторяющийся код выделен в отдельную процедуру в целях оптимизации)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

.def	TimerMode = R25	; входной параметр: перед вызовом, следует проинициализировать байтом DTimerX_Mode, соответствующего таймера

; Памятка: также использует/портит содержимое регистров: TEMP.

;----- Code

DISPLAY_PRINT_TIMER_MODE:
		; Вывести признак "сработавшего сигнала" текущего Таймера (означает, что он досчитал до нуля):
		BST	TimerMode,	MODE_BELLRINGING			; Флаг "гудок звонит":		=0 молчит,	=1 пищит прямо сейчас (время пришло)!
		BRTC	NotRingingTimer__DISPLAY_PRINT_TIMER_MODE		; проверка: если не сработал "сигнал" текущего Таймера...
		RCALL	DISPLAY_PRINT_BELLSIGN					; вывести на индикатор "колбасящийся звоночек"
		RJMP	Exit__DISPLAY_PRINT_TIMER_MODE				; (Примечание: остальные символы выводим, только когда, в текущем режиме, не работает звонок - потому что колбасящийся звоночек, на среднем индикаторе, не оставил бы места для рисования.)
	NotRingingTimer__DISPLAY_PRINT_TIMER_MODE:
		; (состояние: "гудок" текущего Таймера не звонит)

		; Вывести признак "активности хода" таймера:
		BST	TimerMode,	MODE_ENABLED				; Флаг "режим активности":	=0 остановлен,		=1 бежит
		BRTC	NotRunningTimer__DISPLAY_PRINT_TIMER_MODE		; проверка: "секундную чёрточку" выводим, только если текущий таймер запущен...
		RCALL	DISPLAY_PRINT_SECONDSIGN				; вывести на индикатор "чёрточку"
	NotRunningTimer__DISPLAY_PRINT_TIMER_MODE:

		; Вывести признак "направления хода" таймера:
		BST	TimerMode,	MODE_UPDOWN				; Флаг "режим направления":	=0 прямой счёт,	=1 обратный счёт
		BRTS	DownCounter__DISPLAY_PRINT_TIMER_MODE
		SETB	(DOutputDisplayString+PositionM), SegmentBit_D		; "прямой счёт" - секундомер: считает от нуля, +1, до бесконечности.	Отображается: чёрточка снизу.  (Мнемоника: типа, "счётчик катится снизу-вверх".)
		RJMP	Exit__DISPLAY_PRINT_TIMER_MODE
	DownCounter__DISPLAY_PRINT_TIMER_MODE:
		SETB	(DOutputDisplayString+PositionM), SegmentBit_A		; "обратный счёт" - таймер: считает от заданного времени, -1, до нуля.	Отображается: чёрточка сверху. (Мнемоника: типа, "счётчик скатывается сверху-вниз".)

	Exit__DISPLAY_PRINT_TIMER_MODE:
		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
;
; 	DISPLAY_PRINT_SECONDSIGN	(подготовить инфо)
; Когда для текущего режима звонок не работает (при этом он может звонить для другого режима) - 
; на средний индикатор выводится обычная секундная чёрточка.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Памятка: также использует/портит содержимое регистров: TEMP.

;----- Code

DISPLAY_PRINT_SECONDSIGN:
		STOREB	DMain_Mode,	MODE_SECONDSIGN			; Флаг "зажигания на индикаторе мигающей чёрточки" -> T
		LOADB	(DOutputDisplayString+PositionM), SegmentBit_G	; T -> зажигает среднюю чёрточку на среднем индикаторе
		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
;	DISPLAY_PRINT_BELLSIGN	(подготовить инфо)
; Когда для текущего режима звонок сработал - то (одновременно с пищалкой), вместо чёрточки,
; на средний индикатор выводится анимированный символ "звоночка".
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Памятка: также использует/портит содержимое регистров: TEMP.

;----- Code

DISPLAY_PRINT_BELLSIGN:
		STOREB	DMain_Mode,	MODE_SECONDSIGN		; Флаг "зажигания на индикаторе мигающей чёрточки" -> T
		BRTS	BellDown__DISPLAY_PRINT_BELLSIGN	; Примечание: T==1, на первой половине секунды (в это время включается "пищалка" - и пусть, символ "звонок" загорается в нижнем положении)
		LDS	temp,	(DSymbolsTable+SymbolBellUp)
		RJMP	End__DISPLAY_PRINT_BELLSIGN
BellDown__DISPLAY_PRINT_BELLSIGN:
		LDS	temp,	(DSymbolsTable+SymbolBellDown)
End__DISPLAY_PRINT_BELLSIGN:
		STS	(DOutputDisplayString+PositionM), temp
		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
; 	DISPLAY_PRINT_BUZZER	(подготовить инфо)
; Проверить все функции: не звонит ли где звонок?
; Вывести (мигающие) точки для тех функций, будильники которых звонят.
; Включить "бузер", если звонит хоть один из будильников.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Памятка: также использует/портит содержимое регистров: TEMP1, TEMP2.

;----- Code

DISPLAY_PRINT_BUZZER:
		; Подготовить шаблон, который будем лепить в байты выходной строки DOutputDisplayString
		STOREB	DMain_Mode,	MODE_SECONDSIGN		; Флаг "зажигания на индикаторе мигающей чёрточки" -> T
		CLR	temp2					; temp2 = 0		
		BLD	temp2,	SegmentBit_H			; T -> temp2 = 0 или 1 (в бите, соответствующем сегменту Точки на индикаторе)
								; Замечу: "точка" будет зажжена каждые пол секунды, вместе с "секундной чёрточкой" (реализация мигающей точки)

		; Звонит будильник RTC?
		STOREB	DAlarm_Mode,	MODE_BELLRINGING
		BRTC	NotRingingRTC__DISPLAY_PRINT_BUZZER
		LDS	temp1,	(DOutputDisplayString+PositionLH)
		OR	temp1,	temp2				; наложить "точку"
		STS	(DOutputDisplayString+PositionLH), temp1
		RCALL	DISPLAY_TURN_BUZZER_ON			; включить "бузер"
NotRingingRTC__DISPLAY_PRINT_BUZZER:

		; Звонить Timer1?
		STOREB	DTimer1_Mode,	MODE_BELLRINGING
		BRTC	NotRingingTimer1__DISPLAY_PRINT_BUZZER
		LDS	temp1,	(DOutputDisplayString+PositionLL)
		OR	temp1,	temp2				; наложить "точку"
		STS	(DOutputDisplayString+PositionLL), temp1
		RCALL	DISPLAY_TURN_BUZZER_ON			; включить "бузер"
NotRingingTimer1__DISPLAY_PRINT_BUZZER:

		; Звонит Timer2?
		STOREB	DTimer2_Mode,	MODE_BELLRINGING
		BRTC	NotRingingTimer2__DISPLAY_PRINT_BUZZER
		LDS	temp1,	(DOutputDisplayString+PositionM)
		OR	temp1,	temp2				; наложить "точку"
		STS	(DOutputDisplayString+PositionM), temp1
		RCALL	DISPLAY_TURN_BUZZER_ON			; включить "бузер"
NotRingingTimer2__DISPLAY_PRINT_BUZZER:

		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
; 	DISPLAY_TURN_BUZZER_ON	(подготовить инфо)
; Включить пищалку-бузер! (здесь: производится зажиганием нулевого бита в нулевом байте строки DOutputDisplayString)
; 
; Причём, алгоритм усложнён для более художественного писка:
; бузер включается только в первую половину секунды, а во вторую молчит.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Памятка: также использует/портит содержимое регистров: TEMP.

;----- Code

DISPLAY_TURN_BUZZER_ON:
		STOREB	DSleep,	BUZZER_OFF					; Флаг "подавить звучание бузера" -> T
		BRTS	End__DISPLAY_TURN_BUZZER_ON				; (глухой-режим?)

		STOREB	DMain_Mode,	MODE_SECONDSIGN				; Флаг "зажигания на индикаторе мигающей чёрточки" -> T
		BRTC	End__DISPLAY_TURN_BUZZER_ON				; Бузер включается только если T==1, т.е. на первой половине секунды (так эргономичнее: чтобы одновременно включалась и "пищалка", и символ "звонок" загорался в нижнем положении)

		SETB	(DOutputDisplayString+PositionRL),	SegmentBit_H	; Примечание: зажигание этого бита - включает "пищалку"!
End__DISPLAY_TURN_BUZZER_ON:
		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
; 	DISPLAY_PRINT_DIGITS	(подготовить инфо)
; Рендерит на индикаторе цифры "счётчика времени", в "нормальном режиме" отображения (MODE_SETTINGS==0).
; 
; Для универсализации алгоритма, параметр FunctionModeAddress = следует инициализировать адресом ячейки "Режим", соответствующей отображаемой текущей функции.
;
; Также, "data-driven" параметром процедуры является бит MODE_AUTOHOURS, в байте "Режим", соответствующей Функции:
; 	Флаг "автоопределение необходимости отображения часов":
; 	=0, всегда форсировать отображение часов, а секунды никогда не отображаются		(для Часов и Будильника).
; 	=1, автоопределение необходимости отображения часов					(для Таймеров):
;		когда натикало уже много времени - время отображается с часами, без секунд;
; 		когда натикало мало времени - время отображается без часов, с секундами.
;
; Примечание: формат "счётчика времени", в памяти, предполагается следующим: [сначала, 1байт секунды /] затем, 1байт минуты / наконец, 1байт часы...
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

.def	FunctionModeAddressLow	= R28	; YL	(примечание: значение регистра Y изменяется, при выполнении процедуры)
.def	FunctionModeAddressHigh	= R29	; YH

; Памятка: также использует/портит содержимое регистров: TEMP1,TEMP2,TEMP3,TEMP4, X(R27:R26),
;	R25, Z(R31:R30)	(опосредованно в CODE2SYMBOL).

;----- Code


DISPLAY_PRINT_DIGITS:
		; Инициализация
		LD	temp1,	Y				; загрузить байт "Режим", соответствующей отображаемой текущей функции
		BST	temp1,	MODE_AUTOHOURS			; Флаг "автоопределение необходимости отображения часов" -> T
		; Примечание: в регистре Y(R29:R28) будем хранить указатель на исходные данные "счётчика времени":
		SUBI	FunctionModeAddressLow,	(-4)		; смещаем адрес Y+=4, относительно байта "Режим", чтобы указывал на последнюю ячейку "счётчика времени" (Часы), и ещё с коррекцией +1 (здесь, делаем заступ на один байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)
		SBCI	FunctionModeAddressHigh,(-1)
		; Примечание: в регистре X(R27:R26) будем хранить указатель на формируемую "строку отображения на дисплее":
		LDI	XL,	Low(DOutputDisplayString+OutputDisplayString_size)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	XH,	High(DOutputDisplayString+OutputDisplayString_size)	; адрес = "Left High  position" + 1 (заступ на один байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)


Hours__DISPLAY_PRINT_DIGITS:
		LD	temp1,	-Y				; Загружаем байт Часов

		BRTC	ForceHoursShow__DISPLAY_PRINT_DIGITS	; Тест: отображение Часов нельзя пропустить?
		;(случай: здесь, T==1, автоопределение необходимости отображения часов)
		TST	temp1					; Тест: отображение Часов нужно пропустить?
		BREQ	Minutes__DISPLAY_PRINT_DIGITS		; Если Часы==0, то не будем их отображать на экране - перескакиваем к отображения младших разрядов...
	ForceHoursShow__DISPLAY_PRINT_DIGITS:

		CLT						; (параметр T=0) не отображать на индикаторе "ноль" в старшем разряде (ведущий нуль, leading zero) - используется при рендеринге для цифр "Часов".
		RCALL	DISPLAY_PRINT_DIGITS_HELPER		; конвертируем, рендерим...
		LD	temp1,	-X				; Коррекция: после Часов, пропускаем следующую позицию дисплея, в которой разделительная чёрточка.

Minutes__DISPLAY_PRINT_DIGITS:
		SET						; (параметр T=1) полностью отображать двузначную цифру, вместе с ведущим "нулём" - используется при рендеринге цифр "Минут" и "Секунд".
		LD	temp1,	-Y				; Загружаем байт Минут
		RCALL	DISPLAY_PRINT_DIGITS_HELPER		; конвертируем, рендерим...
		; Тест: если индикатор уже заполнен, две позиции (Часы и Минуты) выведены? То вывод Секунд нужно пропустить...
		; Рецепт: проверку будем производить по текущему значению указателя X(R27:R26) - если он уже дошёл до "начала" строки?
		CPI	XL,	Low(DOutputDisplayString+OutputDisplayString_size -5)
		BRNE	Seconds__DISPLAY_PRINT_DIGITS
		CPI	XH,	High(DOutputDisplayString+OutputDisplayString_size -5)
		BRNE	Seconds__DISPLAY_PRINT_DIGITS
		BRTS	End__DISPLAY_PRINT_DIGITS		; прерываем дальнейший рендеринг...

Seconds__DISPLAY_PRINT_DIGITS:
		LD	temp1,	-X				; Коррекция: перед Секундами, пропускаем предыдущую позицию дисплея, в которой разделительная чёрточка.
		LD	temp1,	-Y				; Загружаем байт Секунд
		RCALL	DISPLAY_PRINT_DIGITS_HELPER		; конвертируем, рендерим...

End__DISPLAY_PRINT_DIGITS:
		RET



;---------------------------------------------------------------------------
; Часть повторяющегося кода была вынесена в отдельную подпрограмму, для оптимизации...
; Внимание: это НЕсамостоятельная процедура, не используйте её напрямую! 
; Однако, она будет вызываться сразу из двух разных подпрограмм: DISPLAY_PRINT_DIGITS и DISPLAY_PRINT_SETTINGS. Поэтому описал её параметры, для ясности...
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 	DISPLAY_PRINT_DIGITS_HELPER
; Рендерит одну двоичную цифру в две индикаторные позиции...
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; регистр X(R27:R26)	= указывает на текущую позицию в формируемой "строку отображения на дисплее"	(примечание: этот адрес с заступом на +1 байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)	(причём, при выполнении процедуры, этот адрес декрементируется на 2 байта/позиции)
; регистр TEMP1		= значение, которое вывести в следующие две позиции дисплея	(памятка: TEMP1=0..99, в обычном двоичном коде)

; Также, параметром является status bit "T": 
; 	флаг T==0	- не отображать на индикаторе "ноль" в старшем разряде (ведущий нуль, leading zero) - используется при рендеринге цифр "Часов".
;			  (Причины: более естественно смотрится, а главное экономим электроэнергию - LED жрёт очень много: от 5мА на сегмент. А лишний "нолик" потянет = 6 сегментов>30мА!!!)
; 	флаг T==1	- полностью отображать двузначную цифру, вместе с ведущим "нулём" - используется при рендеринге цифр "Минут" и "Секунд".

; Памятка: также использует/портит содержимое регистров: TEMP1,TEMP2,TEMP3,TEMP4, X(R27:R26),
; 	R25, Z(R31:R30)	(опосредованно в CODE2SYMBOL).
;----- Code


DISPLAY_PRINT_DIGITS_HELPER:
		; Конвертируем бинарное число в ДДК
		; "bin2BCD8" subroutine converts an 8-bit number (fbin) to a 2-digit BCD number (tBCDH:tBCDL)
		; 	Замечу: что код этой процедуры (из чужой, внешней библиотеки) немного неудобно распределяют регистры под параметры - как раз те, самые ходовые, которые используются у меня под TEMPх, и часто меняются другими конструкциями...
		;	Но переназначать регистры в чужом коде я не буду - неблагодарное это дело! Ведь тогда нужно отсмотреть весь код чужой библиотеки, разобрать все зависимости, которые бывают неочевидными... (Хоть, в данном случае, это простая подпрограмма - можно было бы и изменить? Нет, это не "концептуально правильный" подход - лишь куча лишнего гемора, да и лишусь поддержки/совместимости!)
		;MOV	fbin,	temp1				; в данном случае это копирование R16<-R16!
		RCALL	bin2bcd8
		MOV	temp3,	tBCDL				; младший разряд
		MOV	temp4,	tBCDH				; старший разряд

		BRTS	NotBlank__DISPLAY_PRINT_DIGITS_HELPER	; Если разрешено затемнять (флаг T==0)?
		TST	temp4
		BRNE	NotZero__DISPLAY_PRINT_DIGITS_HELPER	; И Если значение старшего разряда == 0?
		LDI	temp4,	SymbolBlank			; Исключение: то вместо цифры "нуля" - выведем пустоту.
	NotBlank__DISPLAY_PRINT_DIGITS_HELPER:
	NotZero__DISPLAY_PRINT_DIGITS_HELPER:

		; Конвертируем символ ДДК в его отображение
		MOV	CodeSymbol,	temp4			; начнём со старшего разряда
		RCALL	CODE2SYMBOL
		ST	-X,	CodeSymbol			; выводим в результирующую строку
		MOV	CodeSymbol,	temp3			; далее, младший разряд
		RCALL	CODE2SYMBOL
		ST	-X,	CodeSymbol			; выводим в результирующую строку	

		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
; 	CODE2SYMBOL - отконвертировать код символа, в его отображение, заданное таблицей "SymbolsTable".
; 
; Примечание: эту процедуру, обычно, имеет смысл использовать только при автоматическом рендеринге цифр: 0..9.
; Если же требуется вывести одиночный символ с известным кодом, то лучше воспользоваться прямой инструкцией:	LDS temp, (DSymbolsTable+SymbolXXX)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

.def	CodeSymbol	= R25	; входной параметр: код символа
				; выходной параметр: отображение символа

; Памятка: также использует/портит содержимое регистров: TEMP, Z(R31:R30).

;----- Code

CODE2SYMBOL:
		LDI	ZL,	Low(DSymbolsTable)		; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	ZH,	High(DSymbolsTable)		; адрес = начало Таблицы

		MOV	temp,	CodeSymbol			; код символа - задаёт счётчик смещений по Таблице
		INC	temp					;

	Loop__CODE2SYMBOL:
		LD	CodeSymbol,	Z+			; загрузить очередное Отображение
		DEC	temp
		BRNE	Loop__CODE2SYMBOL			; крутимся, ПОКА последовательно не доедем до символа с требуемым Кодом-Смещением

		RET



;---------------------------------------------------------------------------
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 
; 	DISPLAY_PRINT_SETTINGS	(подготовить инфо)
; Рендерит на индикаторе "Показатель, который настраивается", при активном "режиме Настройки" (MODE_SETTINGS==1).
; 
; Для универсализации алгоритма, параметр FunctionModeAddress = следует инициализировать адресом ячейки "Режим", соответствующей отображаемой текущей функции.
;
; Примечание: формат "счётчика времени", в памяти, предполагается следующим: [сначала, 1байт секунды /] затем, 1байт минуты / наконец, 1байт часы...
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

;.def	FunctionModeAddressLow	= R28	; YL	(примечание: значение регистра Y изменяется, при выполнении процедуры)
;.def	FunctionModeAddressHigh	= R29	; YH

; Памятка: также использует/портит содержимое регистров: TEMP1,TEMP2,TEMP3,TEMP4, X(R27:R26),
;	R25, Z(R31:R30)	(опосредованно в CODE2SYMBOL).

;----- Code


DISPLAY_PRINT_SETTINGS:
		; Инициализация
		; Примечание: в регистре X(R27:R26) будем хранить указатель на формируемую "строку отображения на дисплее":
		LDI	XL,	Low(DOutputDisplayString+OutputDisplayString_size)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	XH,	High(DOutputDisplayString+OutputDisplayString_size)	; адрес = "Left High  position" + 1 (заступ на один байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)


		; Определить ИНДЕКС текущего параметра, который отображается -> TEMP3: 0=Секунды, 1=Минуты, 2=Часы ?
		; А заодно, переведём указатель в регистре Y(R29:R28) -> на соответствующую ячейку исходных данных "счётчика времени".
		CLR	temp3
		LD	temp2,	Y+				; переводим указатель Y -> на ячейку "Секунды"
		STOREB	DSettings_Mode,	SETTING_SECONDS		; Флаг "находимся в режиме настройки счётчика Секунд" -> T,	DSettings_Mode -> temp
		BRTS	IndexEvaluated__DISPLAY_PRINT_SETTINGS

		INC	temp3
		LD	temp2,	Y+				; переводим указатель Y -> на ячейку "Минуты"
		BST	temp,		SETTING_MINUTES		; Флаг "находимся в режиме настройки счётчика Минут" -> T
		BRTS	IndexEvaluated__DISPLAY_PRINT_SETTINGS

		INC	temp3
		LD	temp2,	Y+				; переводим указатель Y -> на ячейку "Часы"
		BST	temp,		SETTING_HOURS		; Флаг "находимся в режиме настройки счётчика Часов" -> T
		BRTS	IndexEvaluated__DISPLAY_PRINT_SETTINGS

		RJMP	End__DISPLAY_PRINT_SETTINGS		; А если произошла какая-то ошибка и значение регистра DSettings_Mode некорректно, то идти на выход (на дисплей ничего не выводится)...
	IndexEvaluated__DISPLAY_PRINT_SETTINGS:
		LSL	temp3					; temp3 = temp3 * 2		(Примечание: теперь, temp3 = это смещение, в таблице символов DSymbolsTable, на название текущего Параметра, относительно символа с индексом SymbolSeconds.)
		SUBI	temp3,	(-SymbolSeconds)		; temp3 = temp3 + SymbolSeconds	(Примечание: теперь, temp3 = это абсолютный индекс, в таблице символов DSymbolsTable, на название текущего Параметра.)
		PUSH	temp3					; Сохранить temp3 -> в Стеке	(потому что, грядущая вспомогательная процедура DISPLAY_PRINT_DIGITS_HELPER, при исполнении, к неудобству, портит/использует ВСЕ доступные "временные регистры"! в т.ч. и TEMP3, значение которого понадобится на следующем шаге...)


		; Вывести значение Параметра в левый/старший индикатор:
		LD	temp1,	Y				; Загрузить в регистр TEMP1 = значение Параметра, которое требуется вывести в следующие две позиции дисплея	(памятка: TEMP1=0..99, в обычном двоичном коде)
		SET						; Флаг T=1	(полностью отображать двузначную цифру, вместе с ведущим "нулём")
		MOV	YL,	temp3				; (к неудобству, вспомогательная процедура DISPLAY_PRINT_DIGITS_HELPER, при выполнении, портит/использует почти все доступные регистры!.. в т.ч. и TEMP3, значение которого ещё понадобится на следующем шаге -> поэтому, спасём его в регистре Y, который уже больше не нужен.)
		RCALL	DISPLAY_PRINT_DIGITS_HELPER		; конвертируем, рендерим...

		LD	temp1,	-X				; Коррекция: пропускаем следующую позицию дисплея, в которой разделительная чёрточка...

		; Вывести название Параметра в правый/младший индикатор:
		POP	temp3
		MOV	CodeSymbol,	temp3			; первый байт
		RCALL	CODE2SYMBOL
		ST	-X,	CodeSymbol			; выводим в результирующую строку

		INC	temp3
		MOV	CodeSymbol,	temp3			; второй байт
		RCALL	CODE2SYMBOL
		ST	-X,	CodeSymbol			; выводим в результирующую строку

End__DISPLAY_PRINT_SETTINGS:
		RET



.ifdef TURN_DEBUG_OUTPUT_ON
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; Процедура отладочного Вывода на дисплей-индикатор:
;
; 	DISPLAY_PRINT_DEBUGSTUB	(подготовить инфо)
; 	подмена регулярного вывода отладочным в строке байт DOutputDisplayString:
;
; 	Выводит на индикатор (в 16-ричном коде) до двух WATCH-значение некоторого "наблюдаемого параметра".
; 	Адреса наблюдаемых ячеек памяти (WatchValueAddressX) = хардкодятся прямо здесь, в коде, ниже:
; 		WatchValueAddress1 - выводится в левый/старший индикатор	(или, если адрес==(-1), то остаётся регулярный вывод).
; 		WatchValueAddress2 - выводится в правый/младший индикатор	(или, если адрес==(-1), то остаётся регулярный вывод).
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables
;
; Без параметров.
;
; Памятка: также использует/портит содержимое регистров: 
;	TEMP1, TEMP2, X(R27:R26), 
;	R25, Z(R31:R30)			(опосредованноо в CODE2SYMBOL).
;
;----- Code

.equ	WatchValueAddress1 = DEncoder0Status			; адрес "наблюдаемого параметра", который выводится в левый/старший индикатор	(или, если адрес==(-1), то остаётся регулярный вывод).
.equ	WatchValueAddress2 = DEncoder0Counter			; адрес "наблюдаемого параметра", который выводится в правый/младший индикатор	(или, если адрес==(-1), то остаётся регулярный вывод).


DISPLAY_PRINT_DEBUGSTUB:
		; Примечание: в регистре X(R27:R26) будем хранить указатель на формируемую "строку отображения на дисплее":
		LDI	XL,	Low(DOutputDisplayString+OutputDisplayString_size)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	XH,	High(DOutputDisplayString+OutputDisplayString_size)	; адрес = "Left High  position" + 1 (заступ на один байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)

	.if WatchValueAddress1 != (-1)
		LDS	temp1,	WatchValueAddress1		; адрес "наблюдаемого параметра"
		RCALL	DISPLAY_PRINT_DEBUGSTUB_HELPER
	.else
		LD	temp1,	-X				; Коррекция: пропускаем следующую позицию дисплея
		LD	temp1,	-X				; Коррекция: пропускаем следующую позицию дисплея
	.endif

		LD	temp1,	-X				; Коррекция: пропускаем следующую позицию дисплея, в которой разделительная чёрточка...

	.if WatchValueAddress2 != (-1)
		LDS	temp1,	WatchValueAddress2		; адрес "наблюдаемого параметра"
		RCALL	DISPLAY_PRINT_DEBUGSTUB_HELPER
	.endif

		RET



;---------------------------------------------------------------------------
; Часть повторяющегося кода была вынесена в отдельную подпрограмму, для оптимизации...
; Внимание: это НЕсамостоятельная процедура, не используйте её напрямую! 
; Она будет вызываться из подпрограмм: DISPLAY_PRINT_DEBUGSTUB. Описал её параметры, для ясности...
;
; Вспомогательная Процедура Вывода на дисплей-индикатор:
; 	DISPLAY_PRINT_DEBUGSTUB_HELPER
; Рендерит одну двоичную цифру в две индикаторные позиции...
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; регистр X(R27:R26)	= указывает на текущую позицию в формируемой "строку отображения на дисплее"	(примечание: этот адрес с заступом на +1 байт, потому что обращаться к памяти будем с ПРЕДЕКРЕМЕНТОМ)	(причём, при выполнении процедуры, этот адрес декрементируется на 2 байта/позиции)
; регистр TEMP1		= значение, которое вывести в следующие две позиции дисплея	(памятка: TEMP1=0..$FF, в обычном двоичном коде)

; Памятка: также использует/портит содержимое регистров: 
; 	TEMP1, TEMP2, X(R27:R26),
; 	R25, Z(R31:R30)	(опосредованно в CODE2SYMBOL).
;----- Code


DISPLAY_PRINT_DEBUGSTUB_HELPER:

		; Подготовить Значение:
		MOV	temp2,	temp1
		ANDI	temp2,	0b1111				; младший полубайт
		SWAP	temp1
		ANDI	temp1,	0b1111				; старший полубайт

		; Вывести Значение (вместо имеющихся там символов):
		MOV	CodeSymbol,	temp1			; старший полубайт
		RCALL	CODE2SYMBOL
		LD	temp1,	-X
		ANDI	temp1,	0b00000001
		OR	temp1,	CodeSymbol
		ST	X,	temp1				; выводим в результирующую строку

		MOV	CodeSymbol,	temp2			; младший полубайт
		RCALL	CODE2SYMBOL
		LD	temp1,	-X
		ANDI	temp1,	0b00000001
		OR	temp1,	CodeSymbol
		ST	X,	temp1				; выводим в результирующую строку

		RET		

.endif	//.ifdef TURN_DEBUG_OUTPUT_ON



;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; Процедура Вывода на дисплей-индикатор:
;
; 	DISPLAY_REFRESH	(обновить отображение)
; 	отобразить информационную строку DOutputDisplayString на дисплей.
; 	
;	(Примечание: данный код выделен в отдельную процедуру, с целью облегчения 
;	перехода к "динамической индикации" или иным механизмам вывода, в дальнейшем.)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables
;
; Без параметров.
;
; Памятка: также использует/портит содержимое регистров: 
;	TEMP1 (опосредованно для SETB/CLRB/STOREB/LOADB), 
;	TEMP2, TEMP3, TEMP4, 
;	Y(R29:R28).
;
;----- Code


; Примечание: для контроля тайминга гонок сигналов, и соответствия сигналов выдаваемых в порт МК и принимаемых цифровыми микросхемами обвязки, заметим:
; 	Частота МК CPU: CLK_XTAL = 32768Hz
; 	Следовательно, Период одного такта CPU = 1/CLK_XTAL = 30,5 мкс
; 	Если последовательно вывести в порт сигнал PinClock2="0-1-0" - то сформируется "синхроимпульс".
; 	Если данные в порт выводятся инструкциями SBI/CBI, занимающими самое меньшее: 1 такт CPU (на ATtiny10) - то наименьшая ширина синхроимпульса = 1 такт CPU = 30,5 мкс.
;	(Хотя замечу, что на ATTiny25/45/85, длительность инструкций SBI/CBI = 2 такта CPU = ширина Синхроимпульса выходит даже больше, это ещё безопаснее.)
; Datasheet на 74HC164 гласит: 
; 	Минимальная задержка от включения информационного сигнала A до подачи фронта синхры, должна быть, в худшем случае: tsu = 75ns.
; 	Минимальная ширина синхроимпульса (полупериод Clock, когда сигнал равен "лог.1") для уверенной фиксации сигнала, в худшем случае: tw = 120ns (что в 254раз меньше, чем период такта CPU).
; Таким образом, итог: 
; 	Cкорость работы микроконтроллера на 2-3 порядка меньше, чем скорость реакции обвязки!
; 	Следовательно, дополнительных задержек (типа NOP, между инструкциями) вводить не следует, при генерации сигналов в Порт.


DISPLAY_REFRESH:
		CLRB	PORTB,	PinClock2			; Установить сигнал PinClock2="0": базовое положение для процедуры обновления - индикатор выключен/заблокирован	(функционал обработки задержек, для приручения внешней RC-цепочки, управляющей ключом, гасящим дисплей, на время обновления данных)
								; Замечу: Обычное состояние этого бита = "1", следовательно большую часть времени ключ Q2 открыт и индикаторы подключены к шине "Земли" (светятся и отображают информацию)...
								; 	Но сейчас надо выключить индикаторы (заблокировать отображение) - на время, пока мы будем менять содержимое в сдвиговых индикаторных регистрах.
								; 	Для этого, требуется: перевести уровень сигнала PinClock2="0", и пропустить ~7 тактов CPU (задержка RC-цепочки, переключающей ключ), до того, как приступить к изменению содержимого индикаторных регистров. 
								; 	(Примечание: здесь, в дальнейшем коде, пока идёт подготовка к выводу - как раз, эти 7 тактов и пройдут: дополнительные NOP/задержки не требуются...)

		; Задержка для гарантированного выключения Индикаторов	
		; (Примечание: введена по результатам практического эксперимента на макете: особенно при большом Vcc=3V, конденсатор не успевал разрядиться и потому давал помехи по шине Clock2...)
		LDI	TEMP1,	9				; Количество тактов CPU, которое тупить = (ЧИСЛО+1) * 5
		LDI	TEMP2,	0
		LDI	TEMP3,	0
		RCALL	CPU_DUMB_DELAY				; (+5 тактов CPU, на вызов/возврат из функции)

		SETB	DDRB,	PinLight			; переключить вывод порта "Light" на выход (OUT)
		LDI	YL,	Low(DOutputDisplayString)	; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	YH,	High(DOutputDisplayString)	;
		STOREB	DSleep,	TOTAL_BLACKOUT			; Флаг "ВСЯ индикация отключена/подавлена" -> T

		LDI	temp3,	OutputDisplayString_size	; счётчик количества байт, которое требуется вывести
LoopByte__DISPLAY_REFRESH:
		LD	temp2,	Y+				; загружаем очередной байт
		LDI	temp4,	0b00000001			; счётчик количества бит, которое требуется вывести
LoopBit__DISPLAY_REFRESH:
		; Передёрнуть Синхроимпульс для фиксации ПРЕДЫДУЩЕГО выводимого бита:	(Замечу, что при самом первом входе в цикл - будет выведен один мусорный бит. Но это не важно...)
		; (Datasheet на 74HC164 гласит: "Data is entered on each rising edge of the clock.")
		SETB	PORTB,	PinClock2			; вывести "1" в порт	(Сформировать фронт синхроимпульса, по которому бит данных протолкнётся в сдвиговый регистр!)
		CLRB	PORTB,	PinClock2			; вывести "0" в порт	(Замечу: На ATTiny25/45/85, ширина Синхроимпульса выходит = 2 такта CPU = длительность инструкций SBI/CBI)
		; Вывести информационный бит в Порт:
		; (Примечание: Биты каждого Байта следует выводить в Порт, в порядке: "сначала младшие, потом старшие" (little-endian).	Это реализовано с помощью операции LSR: Logical Shift Right >> C.)
		LSR	temp2
		BRCC	Out0__DISPLAY_REFRESH
		BRTS	Out0__DISPLAY_REFRESH			; (гасим всё?)	Если флаг "ВСЯ индикация отключена"==1, то форсировать вывод "лог.0"
		SETB	PORTB,	PinLight			; вывести "1" в порт
		RJMP	FixOut__DISPLAY_REFRESH
	Out0__DISPLAY_REFRESH:
		CLRB	PORTB,	PinLight			; вывести "0" в порт
	FixOut__DISPLAY_REFRESH:
		; Наращиваем счётчики цикла:
		LSL	temp4					; счётчик количества бит, которое требуется вывести
		BRCC	LoopBit__DISPLAY_REFRESH
		DEC	temp3					; счётчик количества байт, которое требуется вывести
		BRNE	LoopByte__DISPLAY_REFRESH

		SETB	PORTB,	PinClock2			; Выдать последний синхроимпульс для фиксации ПОСЛЕДНЕГО выводимого бита...
								; И напоследок, Установить сигнал PinClock2="1": нормальное положение - индикатор включен/отображает	(функционал обработки задержек, для приручения внешней RC-цепочки, управляющей ключом, гасящим дисплей, на время обновления данных)
								; Замечу: здесь, возвращаем сигнал в норму - и через ~7 тактов, включится индикатор...
								; Тут управление сигналами синхроимпульсов на PinClock2 немного извратное - потому что нужно предусмотреть одновременно управление двумя функциями: и сдвиговыми регистрами, и RC-цепочкой (нельзя сделать лишнего переключения: количество импульсов и их тайминги - строго регламентированы!)
		RET



;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; Процедуры Поддержки "спящего режима":
;
;	SLEEPER_RESET
; Разбудить "соню": выключить спящий режим и сбросить таймауты.
; (вызывается по событию: только что была нажата кнопка, или др.)
;
;	SLEEPER_SECOND_ELAPSED
; Рабочий цикл "шарманки" Конечного автомата, реализующего "спящий режим": наращивает таймеры и переключает режимы индикатора.
; (вызывается по событию: прошла очередная 1 секунда)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables
;
; Без параметров.
;
; Памятка: также использует/портит содержимое регистров: TEMP1,	TEMP2.
;
;----- Code


; Разбудить "соню": выключить спящий режим и сбросить таймауты.
; (вызывается по событию: только что была нажата кнопка, или др.)
SLEEPER_RESET:
	.if CSleepTimeout!=0	; (только если спящий режим не отключён)
		OUTI	DSleep,		0			; все режимы сна = выкл.
		OUTI	DSleepCnt,	Low (CSleepTimeout)	; и "обнулить" счётчик таймаута
		OUTI	DSleepCnt+1,	High(CSleepTimeout)	
	.endif
		RET



; Рабочий цикл "шарманки" Конечного автомата, реализующего "спящий режим": наращивает таймеры и переключает режимы индикатора.
; (вызывается по событию: прошла очередная 1 секунда)
; 	Примечание: описание концепции Конечного автомата - см. в "AVR. Учебный курс. Конечный автомат" (с) http://easyelectronics.ru/avr-uchebnyj-kurs-konechnyj-avtomat.html
SLEEPER_SECOND_ELAPSED:
	.if CSleepTimeout!=0	; (только если спящий режим не отключён)

		DEC16M	DSleepCnt
		LDS	temp1,	DSleepCnt
		LDS	temp2,	DSleepCnt+1
		OR	temp1,	temp2
		BRNE	End__SLEEPER_SECOND_ELAPSED		; на счётчике ещё_не_ноль?

		; (состояние: счётчик таймаута дотикал до нуля - надо переключить режим!)
		STOREB	DSleep,	SLEEPMODE_ON			; Флаг "активирован режим экономии электроэнергии (спящий режим)" -> T
		BRTS	FlipDisplay__SLEEPER_SECOND_ELAPSED	; состояние: спящий режим уже активен?
		; (состояние: спящий режим ещё не активен)
		; Активировать "спящий режим":
		SETB	DSleep,		SLEEPMODE_ON
		RJMP	OffDisplay__SLEEPER_SECOND_ELAPSED

	FlipDisplay__SLEEPER_SECOND_ELAPSED:
		; (состояние: спящий режим уже активен)
		STOREB	DSleep,	DISPLAY_OFF			; Флаг "загасить дисплей" -> T
		BRTS	OnDisplay__SLEEPER_SECOND_ELAPSED	; состояние: сейчас фаза "загащенного дисплея"?
	OffDisplay__SLEEPER_SECOND_ELAPSED:
		; (состояние: сейчас фаза включённого дисплея)
		; Загасить дисплей:
		SETB	DSleep,		DISPLAY_OFF		; Гасим дисплей
		OUTI	DSleepCnt,	Low(CSleepDisplayOff)	; И устанавливаем таймаут фазы "загащенного дисплея"
		OUTI	DSleepCnt+1,	High(CSleepDisplayOff)	
		RJMP	End__SLEEPER_SECOND_ELAPSED	
	OnDisplay__SLEEPER_SECOND_ELAPSED:
		; (состояние: сейчас фаза "загашенного дисплея")
		; Включить дисплей:
		CLRB	DSleep,		DISPLAY_OFF		; Включаем дисплей
		OUTI	DSleepCnt,	Low(CSleepDisplayOn)	; И устанавливаем таймаут фазы "включённого дисплея"
		OUTI	DSleepCnt+1,	High(CSleepDisplayOn)	

End__SLEEPER_SECOND_ELAPSED:
	.endif
		RET




;=== END "procDisplayOutput.inc" ===========================================
; coded by (c) Celeron, 2013 @ http://we.easyelectronics.ru/my/Celeron/
.ENDIF
