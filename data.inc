;=== BEGIN "data.inc" ======================================================


;***************************************************************************
;*
;*  Глобальные константы и Псевдонимы регистров
;*
;***************************************************************************
;
; Тут определяются Кастомные пользовательские: 
; 	глобальные константы (через .equ)
; 	псевдонимы регистров (через .def)
;
;
; КРАТКАЯ СПРАВКА:
;
; Q: Чем отличаются директивы .def и .equ ?
; A: .equ означает что «Теперь вот это слово равно/эквивалентно этому числу и вместо числа может быть слово»
;    .def означает что «Теперь этот регистр можно обозвать еще и таким словом»
;
;    Регистру мы можем присвоить кучу разных имен и это не будет ошибкой (варнинг будет, но на него можно забить).
;    А вот заэквивалентить одному слову несколько чисел уже нельзя (наоборот, разным словам одно число — запросто, без проблем).
;
;
; Q: Возможно ли присвоить имя не регистру, а скажем порту в/в, или даже лучше конкретному пину порта!? 
;    Возможно, ли определенным ИМЕНАМ присвоить значение?!
; 
; A: Можно, но DEF - работает ТОЛЬКО С РЕГИСТРАМИ (определяет им псевдонимы)!
;    А вот имена портов - это не более чем: EQU номера порта в имя порта (именно они прописаны в hal.inc файлах, для соответствующих мк).
; 
;    Пример:
; 	.def COK = R26
; 	.def SEDOK = R27
; 	.def Catch = R28
; 	.def Armed = R29
; 
; 	.equ R_ON = 6
; 	.equ R_ON_P = PORTB
; 	.equ R_ON_D = DDRB
; 
; 	.equ R_EN = 7
; 	.equ R_EN_P = PORTB
; 	.equ R_EN_D = DDRB
;
;---------------------------------------------------------------------------



; Основные режимные константы:
.equ	CAlarmRingDuration	= 180	; Продолжительность звонка Будильника (при срабатывании), в сек, [0..255]
.equ	CTimerRingDuration	= 30	; Продолжительность звонка Таймеров обратного счёта (когда время выходит в ноль), в сек, [0..255]


.equ	CSleepTimeout		= 180	; Время с последнего нажатия любой кнопки, после которой экран переходит в "спящий режим", в сек, [0..65535]	(или =0, спящий режим отключён)
; (Примечание: следующие две константы работают только при активном "спящем режиме".)
.equ	CSleepDisplayOff	= 3580	; время загашения индикатора, в сек, [0..65535]
.equ	CSleepDisplayOn 	= 20	; время включения индикатора, в сек, [0..65535]
					; (рекомендуется подбирать последние два таймаута: в сумме, кратными минуте)



; Распиновка выводов ПортаB и соответствующие им названия схемных Сигналов:
; Для простоты, будем полагать, что номера битов в регистрах порта всегда совпадают: PORTBx = DDBx = PINBx.
; Примечание: Light/Scan/Sense - это, на самом деле, один физический вывод Порта, но исполняющий три функции (мультиплексирование).
.equ	PinClock1	= PORTB2	; (OUT)
.equ	PinClock2	= PORTB1	; (OUT)
.equ	PinLight	= PORTB0	; (OUT)
.equ	PinScan		= PORTB0	; (OUT)
.equ	PinSense	= PORTB0	; (IN)



; Временные регистры, используемые в основном прикладном коде
.def	temp	= R16
.def	temp1	= R16
.def	temp2	= R17
.def	temp3	= R18
.def	temp4	= R19




;***************************************************************************
;*
;*  Энергонезависимая память EEPROM (сегмент ППЗУ)
;*
;***************************************************************************
			.ESEG

		; Fi5t предупреждает, в комментарии к http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-eeprom.html
		;	"У атмеловских контроллеров есть так называемая «мертвая зона» EEPROM-a. У 64й атмеги, например, это все адреса от 0?00 — 0?100. Так же была замечена тенденция (по крайней мере на атмегах), чем круче модель (ATMeag32->64->128), тем больше у нее мертвая зона EEPROM. Причем в документации, про нее нифига не написано и подбирать придется в ручную. 
		; 	Ах да, чем же она такая мертвая эта зона. А тем, что запись и чтение в ней происходят через раз, а то и не происходят вообще. Дрочится конечно можно, но лучше оставить эти 100 адресов на советси разработчиков и работать со стабильным ПЗУ."
		; TODO: Протестировать стабильность работы готового устройства! 
		;	Экспериментально определить наличие и размер "мёртвой зоны EEPROM". 
		; 	При необходимости, сместить диапазон используемой памяти на несколько байтов вперёд, за пределы "мёртвой зоны":
		;.ORG	<адрес за пределами "мёртвой зоны EEPROM">	; Note: Byte address



;***** Предустановленные настройки Будильника 

			.equ	EAlarm_size = 4			; размер структуры памяти (в байтах)
EAlarm_SavedSettings:	.DB	CAlarm_DefaultMode,0xFF,0,7	; Примечание: по умолчанию, будильник установлен на 07:00, выключен.
								; (Описание структуры памяти см. как в DAlarm. Байты расположены в порядке: Mode, fake, Minutes, Hours.)



;***** Таблица кодировки отображений символов для вывода на семисегментный индикатор (один символ = 1 байт = 8 бит = 8 сегментов 1 индикатора)

		.equ	SymbolsTable_size = 25		; размер структуры памяти (в байтах)
ESymbolsTable:	.DB	0b11111100	; 0
		.DB	0b01100000	; 1
		.DB	0b11011010	; 2
		.DB	0b11110010	; 3
		.DB	0b01100110	; 4
		.DB	0b10110110	; 5
		.DB	0b10111110	; 6
		.DB	0b11100000	; 7
		.DB	0b11111110	; 8
		.DB	0b11110110	; 9
		.DB	0b11101110	; 10: A
		.DB	0b00111110	; 11: b
		.DB	0b10011100	; 12: C
		.DB	0b01111010	; 13: d
		.DB	0b10011110	; 14: E
		.DB	0b10001110	; 15: F
		.DB	0b00000000	; 16: blank (пусто)
		.DB	0b11000110	; 17: bell up
		.DB	0b00111010	; 18: bell down
		.DB	0b10110110	; 19: "Seconds"-1	(символ заполняет пару индикаторов, используется в "режиме настройки")
		.DB	0b00011010	; 20: "Seconds"-2	(символ заполняет пару индикаторов, используется в "режиме настройки")
		.DB	0b11001100	; 21: "Minutes"-1	(символ заполняет пару индикаторов, используется в "режиме настройки")
		.DB	0b11100100	; 22: "Minutes"-2	(символ заполняет пару индикаторов, используется в "режиме настройки")
		.DB	0b01101110	; 23: "Hours"-1		(символ заполняет пару индикаторов, используется в "режиме настройки")
		.DB	0b00001010	; 24: "Hours"-2		(символ заполняет пару индикаторов, используется в "режиме настройки")
		;	0bABCDEFGH	(примечание: сегмент зажигает "логическая единичка" в разряде)
		;	  76543210	(номера битов, для инструкций манипуляции битами)


; Псевдонимы некоторых спец. символов:
.equ	SymbolBlank	= 16
.equ	SymbolBellUp	= 17
.equ	SymbolBellDown	= 18
.equ	SymbolSeconds	= 19
.equ	SymbolMinutes	= 21
.equ	SymbolHours	= 23

; Псевдонимы сегментов 7-сегментного индикатора:
.equ	SegmentBit_A	= 7
.equ	SegmentBit_B	= 6
.equ	SegmentBit_C	= 5
.equ	SegmentBit_D	= 4
.equ	SegmentBit_E	= 3
.equ	SegmentBit_F	= 2
.equ	SegmentBit_G	= 1
.equ	SegmentBit_H	= 0



; Расшифровка-Соглашение:
;
; В сдвиговый регистр "74HC164" данные (уровень, присутствующий на входах Ax) проталкиваются по фронту Clock2.	(т.е. Clock2 = 0,1,0)
; Бит сначала попадает в ячейку Qa, затем проталкиваются далее: Qa -> Qb -> Qc -> Qd -> Qe -> Qf -> Qg -> Qh.	(LSR: Logical Shift Right >> C)
; где Qa - старший бит, а Qh - младший бит.
; Таким образом, Биты каждого байта следует выводить в порт, в порядке: "сначала младшие, потом старшие" (little-endian).

; Из 5-байтовой отображаемой на дисплее последовательности, первым выводится самый правый (младший) байт (например, единицы секунд). 
; Он 5 раз пропихивается поразрядно слева направо, и попадает в крайний правый разряд-индикатор (little-endian)...
; Всего, информационная ёмкость дисплея (и выводного сдвигового регистра): 5 разрядов по 8 бит.


; Памятка: Каждый разряд дисплея представляет собой следующее расположение сегментов (вид спереди, от наблюдателя):
;
;	 ---A---
;	|	|
;	F	B
;	|	|
;	 ---G---	
;	|	|
;	E	C
;	|	|
;	 ---D---	
;		oH

; There are two important types of 7-segment LED display: 
; 	In a common cathode (CC) display, the cathodes of all the LEDs are joined together and the individual segments are illuminated by HIGH voltages ("логическая единичка").
; 	In a common anode (CA) display, the anodes of all the LEDs are joined together and the individual segments are illuminated by connecting to a LOW voltage ("логический ноль").
; В данном проекте задействован индикатор "SM420361N" - типа "common cathode (CC)"!
; Схематической инверсии электрического логического сигнала, по пути "порт-регистр-индикатор", не производится.
; Т.о. сегмент зажигает "логическая единичка". 	(Выводится в порт последовательно. Декодирование - программное.)




;***************************************************************************
;*
;*  Константные массивы в памяти FLASH (сегмент кода)
;*
;***************************************************************************
			.CSEG

		; Важно! Блок-врезка с константными данными должен располагаться в памяти: 
		; после основного кода, и не пересекаться ни с Boot-блоком, ни с другими врезками!
		; Подберите смещение соответственно:
		;.ORG	(FLASHEND - <количество требуемой под блок констант памяти, в словах по 2байта>)	; Note: Word address
		.ORG	(FLASHEND-50)	; определяем карман из 100байт, в самом конце flash-памяти.


; Зачем это?
; Поскольку в Микроконтроллере зашито больше всего объёма памяти типа Flash, используемой обычно для программного кода, то зачастую, часть из этого пространства остатся незанятой.
; Неиспользуемый остаток может быть использован для хранения массивов неизменных данных: таблица значений функции, псевдокод программных автоматов, таблицы (пере)кодировок, и т.п.


; Пример распределения памяти:
;
; MyConstArray: .db 13, 69, 66, 39, 75, 31
; 		.db 35, 18, 87, 21, 32, 46
;	 	.db 123,38, 86, 89, 93, 75
; 		.db 54, 47, 59, 98, 76, 6
; 		.db 147,59, 239,244,170,66
; 		.db 92, 162,1,  7,  28, 89
; 		.db 78, 5,  15, 154,38, 19
; 		.db 84, 7,  33, 8,  77, 94
; 		.db 93, 56, 5,  99, 89, 54
; 		.db 3,  54, 63, 6,  65, 84
; 		.db 213,90, 83, 111,159,8	
;
; Внимание: здесь, в каждой директиве .DB следует, по возможности, расмещать ПАРНОЕ КОЛИЧЕСТВО чисел - поскольку пары байт упаковываются в пакеты-слова:
; If the DB directive is given in a Code Segment and the expressionlist contains more than one expression, the expressions are packed so that two bytes are placed in each program memory word. 
; If the expressionlist contains an odd number of expressions, the last expression will be placed in a program memory word of its own, even if the next line in the assemby code contains a DB directive. 
; The unused half of the program word is set to zero. A warning is given, in order to notify the user that an extra zero byte is added to the .DB statement.


; Памятка: как обращаться к этой памяти, подгружать из неё данные (инструкцией LPM) - 
; см. статью DI HALT "AVR. Учебный Курс. Работа с памятью" / подраздел "Флеш память" 
; http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-flash-rom.html

;---------------------------------------------------------------------------




;***************************************************************************
;*
;*  Оперативная память SRAM (сегмент ОЗУ)
;*
;***************************************************************************
			.DSEG



;***** Раздел данных прикладной модели:


;** Текущий ИНТЕРАКТИВНЫЙ РЕЖИМ интерфейса

DMain_Mode:		.byte	1	; Режим интерфейса / текущая Функция	(главный регистр кодировки прикладного режима)

.equ	MODE_CURRENT_FUNCTION	= 0	; Три следующих бита DMain_Mode[2:0] кодируют текущий режим интерфейса (функцию), числовым кодом "FunctionID":

; FunctionIDs 				(Внимание: числовые коды существующим функциям менять нельзя - на них уже завязана логика индексных переходов, через SwitchTable__DISPLAY_PREPARE! Можно только увеличивать разрядность или вносить новые коды...)
.equ	FunctionRTC	= 0b000		; часы реального времени	(начальное состояние)
.equ	FunctionALARM	= 0b001		; будильник
.equ	FunctionTIMER1	= 0b010		; таймер1
.equ	FunctionTIMER2	= 0b011		; таймер2
					; = 0b100			(зарезервировано на будущее)
					; = 0b101			(зарезервировано на будущее)
					; = 0b110			(зарезервировано на будущее)
					; = 0b111			(зарезервировано на будущее)

.equ	MODE_SECONDSIGN	= 3		; Флаг "зажигания на индикаторе мигающей чёрточки":
					; 	С одной стороны, отражает бег секунд на индикаторе (=1 зажечь чёрточку).
					; 	С другой стороны, это "старший бит", который увеличивает разрядность Таймера/Счётчика0 (с "полусекунд" >> до "полных секунд").

.equ	MODE_SETTINGS	= 4		; Флаг "находимся в режиме настройки" - для всех функций (часов, будильника, таймеров) означает:
					;	=0, нормальный режим счёта/отображения...
					;	=1, вошёл в режим подстройки (экран помигивает?), поведение текущей функции изменяется (соответствующий счётчик остановлен; реакция на энкодер ввода - меняет значение счётчика вручную; и т.п.)


DSettings_Mode:		.byte	1	; Управление этапами действий, при работе в "режиме настройки"

; Показатель, который настраивается, кодируется битами DSettings_Mode[2:0]:
.equ	SETTING_HOURS	= 5		; Флаг "находимся в режиме настройки счётчика Часов"
.equ	SETTING_MINUTES	= 6		; Флаг "находимся в режиме настройки счётчика Минут"
.equ	SETTING_SECONDS	= 7		; Флаг "находимся в режиме настройки счётчика Секунд"	(примечание: данный параметр настраивается не для всех Функций)




;** Режимы и Счётчик "Часов реального времени"

DClock_Mode:		.byte	1	; Режим	(вспомогательный регистр кодировки прикладного режима)
; Здесь, используются следующие биты:
;.equ	MODE_ENABLED	  = 0		; Флаг "режим активности":	=1 бежит (как обычно),	=0 приостановлен для синхронизации (что происходит одновременно с включением "режима настройки" часов реального времени)
;.equ	MODE_AUTOHOURS	  = 3		; Флаг "форсировать отображение Часов"	("data-driven" параметр для процедуры DISPLAY_PRINT_DIGITS)
;.equ	MODE_INPUTSECONDS = 4		; Флаг "настраивать параметр Секунды"	("data-driven" параметр для процедуры SWITCH_MODE_SETTINGS)

DClock_Seconds:		.byte	1	; секунды	(счётчик времени)
DClock_Minutes:		.byte	1	; минуты
DClock_Hours:		.byte	1	; часы



;** Режимы и Счётчик "Будильника"

DAlarm_Mode:		.byte	1	; Режим	(вспомогательный регистр кодировки прикладного режима)
; Здесь, используются следующие биты:
;.equ	MODE_ENABLED	  = 0		; Флаг "режим активности":	=0 деактивирован,	=1 активен (будет звонить)
;.equ	MODE_BELLRINGING  = 2		; Флаг "гудок звонит":		=0 молчит,		=1 пищит прямо сейчас (время пришло)!
;.equ	MODE_AUTOHOURS	  = 3		; Флаг "форсировать отображение Часов"	("data-driven" параметр для процедуры DISPLAY_PRINT_DIGITS)
;.equ	MODE_INPUTSECONDS = 4		; Флаг "настраивать параметр Секунды"	("data-driven" параметр для процедуры SWITCH_MODE_SETTINGS)

DAlarm_Seconds:		.byte	1	; секунды	(fake-овая ячейка памяти: здесь, не используется, но добавлена в память - для унификации кода обработки данных "счётчика времени")	(Оптимизация: в принципе, в этом байте можно было бы хранить и какую-то полезную информацию - даже байт DMain_Mode сместить сюда, разницы ведь нет... Но здесь, этого делать нельзя из-за наличия фичи сохранения/восстановления данных Будильника в/из EEPROM - инфа побьётся!)
DAlarm_Minutes:		.byte	1	; минуты	(счётчик времени)
DAlarm_Hours:		.byte	1	; часы

DAlarm_RingTimeout:	.byte	1	; Счётчик секунд "сколько бузеру осталось звонить"



;** Режимы и Счётчик "Таймера1"

DTimer1_Mode:		.byte	1	; Режим	(вспомогательный регистр кодировки прикладного режима)
; Здесь, используются следующие биты:
.equ	MODE_ENABLED	  = 0		; Флаг "режим активности":	=0 остановлен,		=1 бежит
.equ	MODE_UPDOWN	  = 1		; Флаг "режим направления":	=0 прямой счёт,		=1 обратный счёт
.equ	MODE_BELLRINGING  = 2		; Флаг "гудок звонит":		=0 молчит,		=1 пищит прямо сейчас (время пришло)!

.equ	MODE_AUTOHOURS	  = 3		; Флаг "автоопределение необходимости отображения часов"	("data-driven" параметр для процедуры DISPLAY_PRINT_DIGITS)
					; 	=0, всегда форсировать отображение часов, а секунды никогда не отображаются		(для Часов и Будильника).
					; 	=1, автоопределение необходимости отображения часов					(для Таймеров):
					;		когда натикало уже много времени - время отображается с часами, без секунд;
					; 		когда натикало мало времени - время отображается без часов, с секундами.

.equ	MODE_INPUTSECONDS = 4		; Флаг "настраивать параметр Секунды"	("data-driven" параметр для процедуры SWITCH_MODE_SETTINGS)
					; 	=0, настраивать два показателя: только Часы и Минуты, а Секунды просто обнуляются	(для Часов и Будильника)
					; 	=1, настраивать три показателя: Часы, Минуты, Секунды					(для Таймеров)

DTimer1_Seconds:	.byte	1	; секунды	(счётчик времени)
DTimer1_Minutes:	.byte	1	; минуты
DTimer1_Hours:	 	.byte	1	; часы

DTimer1_RingTimeout:	.byte	1	; Счётчик секунд "осталось звонить"
DTimer1_FunctionID:	.byte	1	; Байт кодирует "режим интерфейса" = равный числовому коду в DMain_Mode[2:0] (см. расшифровку в DMain_Mode / MODE_CURRENT_FUNCTION), соответствующий текущему Таймеру.



;** Режимы и Счётчик "Таймера2"

DTimer2_Mode:		.byte	1	; Режим	(вспомогательный регистр кодировки прикладного режима)
; Здесь, используются те же биты, что и для "Таймера1"...

DTimer2_Seconds:	.byte	1	; секунды	(счётчик времени)
DTimer2_Minutes:	.byte	1	; минуты
DTimer2_Hours:		.byte	1	; часы

DTimer2_RingTimeout:	.byte	1	; Счётчик секунд "осталось звонить"
DTimer2_FunctionID:	.byte	1	; Байт кодирует "режим интерфейса" = равный числовому коду в DMain_Mode[2:0] (см. расшифровку в DMain_Mode / MODE_CURRENT_FUNCTION), соответствующий текущему Таймеру.



; Для справки: 
; Формат "счётчика времени", в памяти, выбран следующим ("little-endian"): [сначала, 1байт секунды /] затем, 1байт минуты / наконец, 1байт часы.
; Я долго думал и сомневался, а может стоило использовать "big-endian" формат: Часы/Минуты[/Секунды]?	Это бы упростило некоторые участки кода... Да и не пришлось бы, для унификации кода, вводить fake-ячейку "Секунд" для Будильника...
; Но, в итоге, остановился всё же на "little-endian" варианте - с другой стороны, для поддержки кода, это безопаснее в долгосрочной перспективе:	Например, если потребуется, это позволит гармонично расширить "счётчик времени", добавив к нему ещё и "Дату" (добавить поля День/Месяц/Год) - не меняя всего существующего кода, завязанного на структуру памяти, работающего только с "Временем"!



;---------------------------------------------------------------------------
;***** Индикация (вывод)

DSymbolsTable:	.byte	SymbolsTable_size	; Таблица кодировки отображений символов для вывода на семисегментный индикатор (один символ = 1 байт = 8 бит = 8 сегментов 1 индикатора)
						; Примечание: данная область в оперативной памяти - является буфферной, инициализируется данными из EEPROM, при запуске микроконтроллера.



			.equ	OutputDisplayString_size = 5	; размер структуры памяти (в байтах)
DOutputDisplayString:	.byte	OutputDisplayString_size	; 5-байтовая отображаемая на дисплее последовательность, кодирует содержимое 5шт. 7-сегментных индикаторов.
								; Соглашение: Первый (нулевой) байт строки - первым выводится в Порт - это самый правый индикатор (например, "единицы секунд", в данном случае).
; Смешения индикаторов дисплея, относительно начала строки:
.equ	PositionRL	= 0	; Right Low  position
.equ	PositionRH	= 1	; Right High position
.equ	PositionM	= 2	; Middle     position
.equ	PositionLL	= 3	; Left Low   position
.equ	PositionLH	= 4	; Left High  position



DSleep:	.byte	1			; Режим экономии электроэнергии (спящий режим):
					; 	Используется для отключения вывода (затемнения экрана, бузера) в режиме экономии энергии.
					; 	На работе основных функций (сканировании кнопок, ход таймеров, обсчёт математики данных) это никак не сказывается.
					;	(Может также использоваться для реализации спецэффектов: например, помигивания экрана...)

.equ	SLEEPMODE_ON	= 1		; Флаг "активирован режим экономии электроэнергии (спящий режим)": 
					;	=0 нормальный режим отображения...
					;	=1 активирован "спящий режим".
					; 		Включается: после заданного таймаута с момента последнего нажатия любой кнопки, после которого экран переходит в "спящий режим".
					; 		Реализуется: большую часть времени экран не отображает; периодически включается на неск.сек, и тухнет вновь... (?)

.equ	DISPLAY_OFF	= 2		; Флаг "загасить дисплей" - для всех функций (часов, будильника, таймеров) означает:
					;	=0 нормальный режим отображения...
					;	=1 индикаторы временно выключены (слепой-режим)

.equ	BUZZER_OFF	= 3		; Флаг "подавить звучание бузера" - для всех функций (часов, будильника, таймеров) означает:
					;	=0 бузер будет пищать в обычном режиме...
					;	=1 питание бузера отключено (глухой-режим)	[Пригодится на случай: если вы - в самолёте или в вагоне токийского метро. ;)]

.equ	TOTAL_BLACKOUT	= 4		; Флаг "ВСЯ индикация отключена/подавлена"
					; (на будущее) Я пока не знаю зачем это может пригодиться? Просто эта фича легко реализовалась, через процедуру DISPLAY_REFRESH.
					;	=0 нормальный режим отображения...
					;	=1 форсировать отключение всей индикации (и вывод на индикатор, и бузер)! 

.equ	WAKEUP_BUTTONS_HAVE_PREPARED =5	; Флаг "события всех Кнопок обнулены, готов проснуться по любой следующей кнопке"	(это вспомогательный флаг для работы подсистемы "Выход из Спящего режима")
					; 	=0 ещё не вошёл в спящий режим, или заснул но ещё не обнулил кнопки?
					; 	=1 уже сплю и обнулил статусы кнопок - теперь внимательно слежу за ними, по следующему событию проснусь...


DSleepCnt:	.byte	2	; Счётчик таймеров "спящего режима" (обсчитывает таймауты: перед активацией спящего режима, а затем, время пригашения и время включения индикатора)




;---------------------------------------------------------------------------
;***** Сканирование кнопок (ввод)


DKeyScanCnt:	.byte	1	; Счётчик циклов запуска процедуры сканирующей кнопки


; Настройка количеств входных каналов, которые обрабатываются в данной схеме:
.equ	CEncoderInputChannelCount = 2	; здесь, всегда чётное число - поскольку у Энкодеров по два входных канала!
.equ	CButtonInputChannelCount  = 5	; здесь, количество простых "тактовых кнопок".
.equ	CSkipInputChannelCount    = 1	; здесь, остаток до полной разрядности сдвигового регистр (или больше - главное, чтоб не меньше).
; (Примечание: данные константы используются в [текущей реализации] процедуры сканирующей кнопки KEY_SCAN_INPUT.)
; (Важно: СУММА данных количеств должна быть РАВНА разрядности сдвигового регистра - чтобы бегущая сканирующая "1" прошла весь регистр!)
; (Внимание: по особенностям реализации, порядок обработки каналов захардкоден в KEY_SCAN_INPUT - в том же порядке, как расположены регистры данных в блоках памяти, ниже. А эти параметры выведены сюда - для наглядности и удобства поддержки кода.)


; Символические имена Каналов, в зависимости от порядка их опроса:	(приведены для справки, не используются)
; Cоответствуют индексам регистров в блоке Интегратора...		(нумерация начинается с =0)
; И также, косвенно описывают порядок следования статус-регистров Кнопок и Энкодера, в блоках данных, ниже...
;.equ	CEncoderAC	= 0	; выход сдвигового регистра:  3-Qa
;.equ	CEncoderBC	= 1	; выход сдвигового регистра:  4-Qb
;.equ	CButtonEncoder	= 2	; выход сдвигового регистра:  5-Qc
;.equ	CButtonStart	= 3	; выход сдвигового регистра:  6-Qd
;.equ	CButtonRTC	= 4	; выход сдвигового регистра: 10-Qe
;.equ	CButtonTimer1	= 5	; выход сдвигового регистра: 11-Qf
;.equ	CButtonTimer2	= 6	; выход сдвигового регистра: 12-Qg
;.equ	CButtonNone	= 7	; выход сдвигового регистра: 13-Qh
; (Примечание: в [текущей реализации] "конвеера опроса кнопок" эти константы не используются - тут Каналы безличные.)




;** Регистры Интегратора		(внимание: по особенностям данной реализации, наличие этого блока в памяти требуется всегда, даже если функция Интегратора отключена / не требуется)
DInputIntegrator:			; доступ по имени Вектора + Смещение (индекс)... или
DInput0Integrator:	.byte	1	; доступ по прямому адресу Именованной ячейки
DInput1Integrator:	.byte	1
DInput2Integrator:	.byte	1
DInput3Integrator:	.byte	1
DInput4Integrator:	.byte	1
DInput5Integrator:	.byte	1
DInput6Integrator:	.byte	1
;DInput7Integrator:	.byte	1	; Примечание: этот канал физически не подключён (не используется)

.equ	INTEGRATOR_IS_PRESSED	= 7	; Флаг "интегральное состояние канала" (он же Negative Flag "N"), означает: ="0" (кнопка отпущена) или ="1" (кнопка нажата).


; Настройка Интегратора (функции математического подавления звона и помех):
; "Глубина Защёлки" интегратора - аналогична "постоянной времени" помехоподавляющей RC-цепи...
; Допустимые значения:	= [1..128]
.equ	CButtonLatchDepth  = 3	; глубина защёлки интегратора, для опроса тактовых Кнопок = количество циклов опроса, в течение которых кнопка должна возвращать статус "1", чтобы посчитаться "нажатой" или "0", чтобы посчитаться "отпущенной".
.equ	CEncoderLatchDepth = 2	; глубина защёлки интегратора, для опроса контактных групп Энкодера... в целом, то же, что и для обычных тактовых кнопок, но для Энкодера - "глубина защёлки" задаётся отдельно и на порядок меньше! Поскольку контакты Энкодера более стабильны и помехоустойчивы, а кроме того, Энкодер переключается ГОРАЗДО чаще, чем тактовые Кнопки!
; (Важно: нельзя делать значения этих констант слишком большими, а частоту запуска процедуры сканирующей кнопки KEY_SCAN_INPUT слишком редкой - иначе, можно получить ситуацию "долгого отклика" на нажатия или, хуже того, что нажатия кнопок или поворот энкодера - перестанут фиксироваться вообще!)



;** Регистры Статуса Энкодера		(внимание: по особенностям данной реализации, в памяти этот блок располагаются сразу перед блоком статус-регистров кнопок - в том же порядке, как расположены исходные регистры в блоке Интегратора)
DEncoderStatus:
DEncoder0Status:	.byte	1	; пара регистров: регистр "Статуса"		(Примечание: статус-регистр энкодера, напрямую, никогда не используется прикладным кодом.)
DEncoder0Counter:	.byte	1	; и сразу следом: регистр "Счётчик тиков"	(Формат счётчика: особой специальной структуры не содержит. Это просто знаковое целое число: Signed Int = [-128..127])

.equ	ENCODER_STATUS_X1	= 0	; Предыдущее        состояние энкодера: значение входного канала AC(X1)
.equ	ENCODER_STATUS_Y1	= 1	; Предыдущее        состояние энкодера: значение входного канала BC(Y1)
.equ	ENCODER_STATUS_PRECOUNTER = 2	; Следующие два бита - это предварительный счётчик =1..4, через который "по 4 переключения входных сигналов на один тик" преобразуются к фактическому числу тиков, накапливаемому в регистре "счётчика тиков" энкодера...
.equ	ENCODER_STATUS_X2	= 4	; Последнее/текущее состояние энкодера: значение входного канала AC(X2)
.equ	ENCODER_STATUS_Y2	= 5	; Последнее/текущее состояние энкодера: значение входного канала BC(Y2)
.equ	ENCODER_STATUS_F2	= 7	; Последнее/текущее состояние энкодера: вычисленное направление вращения (F2) - это самая нужная, итоговая статусная информация: в какую сторону осуществлён последний тик поворота?
; Кодировка:
; 	F = 0	C.W., 	вращение по часовой ("правый винт")	(+1) к счётчику
; 	F = 1	C.C.W.,	вращение против часовой ("левый винт")	(-1) к счётчику
; 	кодировка входных каналов X,Y (=0 или 1), здесь, в принципе, не важна - используется лишь порядок их переключения...


; Советы по порядку тестирования Энкодера:
; 	Замечу, однако, что прикладной код никогда не использует "статусный регистр энкодера" напрямую!
; 	Он, вспомогательный, нужен лишь для вычисления направления вращения энкодера, используя булеву функцию: F2(x1,x2,y1,y2) = (НЕ(x1) * y2) + (x1 * НЕ(y2)).
; 	Вращения энкодера (если таковые были произведены, и их направление) - инкрементируются к регистру "двунаправленного аддитивного счётчика тиков" энкодера.
; 	(Всё это происходит в служебных функциях "конвеера обработки кнопок".)
; "Счётчик тиков" является конечным в конвеере обработки кнопок, и его использует прикладной код для реакции на жесты с энкодером:
; 	если DEncoderCounter == 0, то вращений [с момента последней обработки] не было, ничего делать не нужно.
; 	если DEncoderCounter > 0,  то зафиксированы вращения, причём в сумме, больше провернули по часовой стрелке: положительное число [1..127] в регистре равно числу тиков [с момента последней обработки].
; 	если DEncoderCounter < 0,  то зафиксированы вращения, причём в сумме, больше провернули против часовой стрелке: отрицательное число [-128..-1] в регистре равно числу тиков [с момента последней обработки].
; 	Причём, между обработками событий энкодера прикладным кодом (которые запускается гораздо реже, чем опрос энкодера) пользователь может колбасить ручку энкодера произвольно в разные стороны, а итоговый результат будет правильно отражён в "Счётчике тиков"!
; В обработчике событий - просто приплюсуйте результат из "Счётчика тиков" к вашей управляемой переменной величине...
; 	А затем, после обработки энкодера прикладным кодом и произведения ответной реакции, "СБРОСьте" регистр "Счётчик тиков" в ноль (но "статусный регистр" энкодера не трогайте!) -> так снова устанавливается статус-кво: энкодер = "не вращался".
; 	Это простой способ сообщить остальному прикладному коду, что данное событие уже обработано и не требует дальнейшего участия!



;** Регистры Статуса Кнопок		(внимание: по особенностям данной реализации, в памяти этот блок располагаются сразу после блока статус-регистров энкодеров - в том же порядке, как расположены исходные регистры в блоке Интегратора)
DButtonStatus:
DButtonStartStatus:	.byte	1	; "СТАРТ/СТОП" - кнопка на Энкодере, самая большая заметная и эргономичная (ожидается, что пользователь будет её нажимать чаще всего)
DButtonSetStatus:	.byte	1	; "УСТАНОВКА"  - кнопка справа под Энкодером. Используется для ввода интерфейса в режим подстройки часов/таймеров.
DButtonRTCStatus:	.byte	1	; перекл.на функцию "Часов/Будильника"
DButtonTimer1Status:	.byte	1	; перекл.на функцию "Секундомера/Таймера №1"
DButtonTimer2Status:	.byte	1	; перекл.на функцию "Секундомера/Таймера №2"

.equ	BUTTON_HOLDING_TIME	= 0	; Пять битов   DButtonStatus[4:0] = счётчик количества полусекунд, в течение которых Кнопка удержива(лась/ется) "нажатой".	(фиксирует время до 16сек!)
.equ	BUTTON_STATUS_CODE	= 5	; В трёх битах DButtonStatus[7:5] = кодируется итоговый "статус-код кнопки" (см. ниже макроопределения констант).
.equ	BUTTON_HOLDEN_LONG	= 5	; Флаг "времени удержания" кнопки: 0-короткое или 1-длинное.
.equ	BUTTON_IS_PRESSED	= 6	; Флаг "зафиксировано полноценное нажатие кнопки": "0" - кнопка не нажималась, "1" - было нажатие.
.equ	BUTTON_IS_HOLDDOWN	= 7	; Флаг "кнопка удерживается в нажатом состоянии": "0" - сейчас кнопка "отпущена", "1" - сейчас кнопка "нажата и удерживается".

; "Button Status Codes" = BUTTON_STATUS_CODE		(полагаю: для описания большинства распространённых "жестов" с кнопками - хватит 4 ситуации):
.equ	BSC_NotPressed	= 0b000	; "не нажата"		(исходное положение для всех кнопок - бывает только после "сброса")
.equ	BSC_ShortHold	= 0b100	; "короткое удержание"	(кнопка нажата, и всё ещё удерживается, пока "короткое" время)
.equ	BSC_LongHold	= 0b101	; "длинное удержание"	(кнопка нажата, и всё ещё удерживается, уже "длительное" время)
.equ	BSC_ShortPress	= 0b010	; "короткое нажатие"	(кнопка была нажата, и затем отпущена, а время её удержания было "незначительным")
.equ	BSC_LongPress	= 0b011	; "длинное нажатие"	(кнопка была нажата, и затем отпущена, а время её удержания было "длительным")


; Советы по порядку тестирования Кнопок:

; Совет: для тестирования состояния кнопок по паттерну BUTTON_STATUS_CODE - можно использовать библиотечные макросы: IF_BUTTON_HAVE_STATUS, AND_BUTTON_HAVE_STATUS, OR_BUTTON_HAVE_STATUS (последние два используются в комбинации, для тестирования "кнопочных аккордов" - см.ниже).

; Совет: (кроме сравнения по паттерну BUTTON_STATUS_CODE) в прикладном коде, для тестирования статуса кнопки - можно воспользоваться инструкцией "побитового сдвига влево" регистра статуса (LSL DButtonStatus):
;	После первого  сдвига: флаг "C" = удерживается ли кнопка в данный момент?
;	После второго  сдвига: флаг "C" = было ли зафиксировано полноценное нажатие кнопки (keypress=нажал+отпустил)?
;	После третьего сдвига: флаг "C" = длительность времени удержания?
;	Замечу: этот метод оптимальнее для реализации одновременного перебора всех возможных вариантов состояния ОДНОЙ кнопки...

; Совет: кроме тестирования чистого "статус-кода кнопки", можно также смотреть на "счётчик времени удержания кнопки" - и различать также ситуации "очень длительных" удерживаний кнопок.
; 	Но замечу, что эти ситуации уже не кодируются в "статус-коде кнопки", т.к. довольно редки - если требуется, данный функционал следует самостоятельно реализовать в прикладном коде, на основании арифметического сравнения (инструкцией CPI) со значением счётчика BUTTON_HOLDING_TIME... (Это самый функциональный способ!)
; 	Также, при оценке прошедшего "времени удержания кнопки", на основании "счётчика времени удержания кнопки" - можно ориентироваться не на абсолютное значение счётчика BUTTON_HOLDING_TIME, а на его отдельные биты:
;		номер бита:		4	3	2	1	0
;		вес двоичного разряда:	16	8	4	2	1
;		время, в секундах:	8сек	4сек	2сек	1сек	0.5сек
.equ	BUTTON_HOLDEN_SLIGHTLY	= BUTTON_HOLDING_TIME+0	; при удержании кнопки свыше >=0.5сек,	когда в этом разряде ВПЕРВЫЕ появляется единичка - наступает ситуация: кнопка удерживается "совсем чуть-чуть".
.equ	BUTTON_HOLDEN_BRIEFLY	= BUTTON_HOLDING_TIME+1	; при удержании кнопки свыше >=1сек,	когда в этом разряде ВПЕРВЫЕ появляется единичка - наступает ситуация: кнопка удерживается "кратковременно".
.equ	BUTTON_HOLDEN_MODERATELY= BUTTON_HOLDING_TIME+2	; при удержании кнопки свыше >=2сек,	когда в этом разряде ВПЕРВЫЕ появляется единичка - наступает ситуация: кнопка удерживается "умеренно".
.equ	BUTTON_HOLDEN_PROLONGED	= BUTTON_HOLDING_TIME+3	; при удержании кнопки свыше >=4сек,	когда в этом разряде ВПЕРВЫЕ появляется единичка - наступает ситуация: кнопка удерживается "продолжительно".
.equ	BUTTON_HOLDEN_SUSTAINED	= BUTTON_HOLDING_TIME+4	; при удержании кнопки свыше >=8сек,	когда в этом разряде ВПЕРВЫЕ появляется единичка - наступает ситуация: кнопка удерживается "непрерывно".
; 	Примечание: но нужно помнить, что это биты "двоичного счётчика", который постоянно увеличивается - и соответственно, позиционные биты периодически то включаются, то гасятся... 
; 	Поэтому, чтобы отреагировать на ПЕРВЫЙ прошедший интервал Xполусекунд - нужно периодически опрашивать статус-регистр кнопки (гораздо чаще, чем каждые 0.5сек) и отловить ПЕРВОЕ появление единички в выбранном разряде. И тут же: отреагировать на событие прикладным кодом, а затем, сразу "СБРОСить статус-регистр".
; 		(Иначе, если не сбрасывать регистр, то счётчик продолжит набегать и будет глюкодром: единица будет сменятся нулём, затем опять единица - путаница... Кроме того, не удобно отслеживать серийные реакции прикладного кода... Т.е. не рекомендую побитово использовать счётчик, без сброса после первого события! 
; 		Если же нужно более сложное поведение кнопки, серийные реакции и т.п., - используйте полноценные арифметические сравнения со значением счётчика...)

; Совет: чтобы разнообразить варианты входных сигналов, прикладной код также может воспринимать "кнопочные аккорды" - тестировать группы кнопок на наличие одновременных нажатий/удержаний. Однако, делать это нужно в определённом приоритетном порядке:
; 	Cначала, проверить были ли нажатия отдельных кнопок, при удержании других "кнопок-модификаторов - типа как Shift/Ctrl/Alt"?	Подсказка: У основной кнопки, которая "нажималась" - статус BUTTON_STATUS_CODE=="ShortPress/LongPress"; при этом, у модификаторов, при "удержании в нажатом состоянии" - установлен бит BUTTON_IS_HOLDDOWN==1...
;	Затем, проверить простые одиночные нажатия отдельных кнопок: у которых статус=="ShortPress/LongPress"?
;	Затем, проверить группы кнопок на одновременное удержание: у которых статус=="LongHold"?	Причём, таким образом, можно проверить, последовательно, несколько групп: от более общих множеств, к более частным - с меньшим числом входящих кнопок...
;	И наконец, проверить отдельные кнопки на длительное удержание: статус=="LongHold"?

; Совет: во избежание ложных повторных срабатываний событий, после обработки статуса кнопки прикладным кодом и произведения ответной реакции, "СБРОСьте" статусный регистр - это простой способ сообщить остальному прикладному коду, что данное событие уже обработано и не требует дальнейшего участия... Причём:
; 	После обработки статус-кодов BSC_*Press (замечу, что физическая кнопка уже отпущена),     статус-регистр следует "сбросить в ноль"    (CLR) -> так снова устанавливается статус-кво "не нажата" (исходное положение для всех кнопок)...
; 	После обработки статус-кодов BSC_*Hold  (замечу, что физическая кнопка ещё удерживается), статус-регистр следует "сбросить в единицы" (SER) -> так в регистре установится ошибочный статус-код, который не будет спутан ни с одной из разрешённых комбинаций, и запретит прикладному коду реакцию на эту кнопку.	(Это служебное, исключительное состояние статус-регистра: "фиксация, до ожидания следующего отпускания" кнопки - ОТЛОЖЕННЫЙ СБРОС...)
; 		Но в то же время, при следующем отпускании физической кнопки, статус-регистр будет АВТОМАТИЧЕСКИ "сброшен в ноль", в исходное положение!	(Это исключительная реакция конвеера обработки кнопок: лишнее нажатие на кнопку не будет зафиксировано!)
; 	А вообще, чтобы не заморачиваться: В ЛЮБЫХ СЛУЧАЯХ (нажата кнопка или отжата, или аккорд отработали), после обработки статус-кодов - СБРАСЫВАЙТЕ статус-регистры всех отработанных кнопок "В ЕДИНИЦЫ (SER)"! Так установится статус "ОТЛОЖЕННЫЙ СБРОС", который, даже если кнопка уже отжата, то при следующем цикле конвеера - будет "сброшен в ноль", когда требуется, автоматически. Это безопасный стиль программирования!
; 		При таком стиле программирования - кнопка работает "с триггером защёлкой-состояния". Вариант поведения "с триггером": заставляет пользователя отпускать кнопку каждый раз, перед её следующим нажатием - что обычно полезно, ибо предотвращает серии ошибочных повторных срабатываний кнопки...
; 		(Хотя, в некоторых специфических случаях применения, можно и отходить от этого правила - бывает полезно использовать кнопки "без триггера защёлки-состояния": для умышленной организации серийных реакций на нажатую и удерживаемую кнопку...)


; Настройка Таймаута "времени удержания" Кнопки, для генерации статус-кодов:
.equ	CShortButtonTouchDuration = 3	;<1.5 сек	; максимальное время удержания кнопки (количество полных полусекунд) до которого ещё фиксируется статус-код "ShortPress/ShortHold", а свыше или равно - уже "LongPress/LongHold"...
; (Примечание: данная константа используется в [текущей реализации] процедуры KEY_ENHANCE_TIME_FOR_ALL_BUTTONS.)




;=== END "data.inc" ========================================================
; coded by (c) Celeron, 2013  http://inventproject.info/
